[
    {
        "line": 180,
        "character": 27,
        "queryLine": 180,
        "queryCharacter": 0,
        "functionName": "LidarMarkerLocalizer::main_process",
        "firstLine": "void LidarMarkerLocalizer::main_process(const PointCloud2::ConstSharedPtr & points_msg_ptr)",
        "content": "void LidarMarkerLocalizer::main_process(const PointCloud2::ConstSharedPtr & points_msg_ptr)\n{\n  const builtin_interfaces::msg::Time sensor_ros_time = points_msg_ptr->header.stamp;\n\n  // (1) check if the map have be received\n  const std::vector<landmark_manager::Landmark> map_landmarks = landmark_manager_.get_landmarks();\n  const bool is_received_map = !map_landmarks.empty();\n  diagnostics_interface_->add_key_value(\"is_received_map\", is_received_map);\n  if (!is_received_map) {\n    std::stringstream message;\n    message << \"Not receive the landmark information. Please check if the vector map is being \"\n            << \"published and if the landmark information is correctly specified.\";\n    RCLCPP_INFO_STREAM_THROTTLE(this->get_logger(), *this->get_clock(), 1000, message.str());\n    diagnostics_interface_->update_level_and_message(\n      diagnostic_msgs::msg::DiagnosticStatus::WARN, message.str());\n    return;\n  }\n\n  // (2) get Self Pose\n  const std::optional<autoware::localization_util::SmartPoseBuffer::InterpolateResult>\n    interpolate_result = ekf_pose_buffer_->interpolate(sensor_ros_time);\n\n  const bool is_received_self_pose = interpolate_result != std::nullopt;\n  diagnostics_interface_->add_key_value(\"is_received_self_pose\", is_received_self_pose);\n  if (!is_received_self_pose) {\n    std::stringstream message;\n    message << \"Could not get self_pose. Please check if the self pose is being published and if \"\n            << \"the timestamp of the self pose is correctly specified\";\n    RCLCPP_INFO_STREAM_THROTTLE(this->get_logger(), *this->get_clock(), 1000, message.str());\n    diagnostics_interface_->update_level_and_message(\n      diagnostic_msgs::msg::DiagnosticStatus::WARN, message.str());\n    return;\n  }\n\n  ekf_pose_buffer_->pop_old(sensor_ros_time);\n  const Pose self_pose = interpolate_result.value().interpolated_pose.pose.pose;\n\n  // (3) detect marker\n  const std::vector<landmark_manager::Landmark> detected_landmarks =\n    detect_landmarks(points_msg_ptr);\n\n  const bool is_detected_marker = !detected_landmarks.empty();\n  diagnostics_interface_->add_key_value(\"detect_marker_num\", detected_landmarks.size());\n\n  // (4) check distance to the nearest marker\n  const landmark_manager::Landmark nearest_marker = get_nearest_landmark(self_pose, map_landmarks);\n  const Pose nearest_marker_pose_on_base_link =\n    autoware_utils_geometry::inverse_transform_pose(nearest_marker.pose, self_pose);\n\n  const double distance_from_self_pose_to_nearest_marker =\n    std::abs(nearest_marker_pose_on_base_link.position.x);\n  diagnostics_interface_->add_key_value(\n    \"distance_self_pose_to_nearest_marker\", distance_from_self_pose_to_nearest_marker);\n\n  const bool is_exist_marker_within_self_pose =\n    distance_from_self_pose_to_nearest_marker <\n    param_.limit_distance_from_self_pose_to_nearest_marker;\n\n  if (!is_detected_marker) {\n    if (!is_exist_marker_within_self_pose) {\n      std::stringstream message;\n      message << \"Could not detect marker, because the distance from self_pose to nearest_marker \"\n              << \"is too far (\" << distance_from_self_pose_to_nearest_marker << \" [m]).\";\n      diagnostics_interface_->update_level_and_message(\n        diagnostic_msgs::msg::DiagnosticStatus::OK, message.str());\n    } else {\n      std::stringstream message;\n      message << \"Could not detect marker, although the distance from self_pose to nearest_marker \"\n              << \"is near (\" << distance_from_self_pose_to_nearest_marker << \" [m]).\";\n      RCLCPP_INFO_STREAM_THROTTLE(this->get_logger(), *this->get_clock(), 1000, message.str());\n      diagnostics_interface_->update_level_and_message(\n        diagnostic_msgs::msg::DiagnosticStatus::WARN, message.str());\n    }\n    return;\n  }\n\n  // for debug\n  if (pub_marker_detected_->get_subscription_count() > 0) {\n    PoseArray pose_array_msg;\n    pose_array_msg.header.stamp = sensor_ros_time;\n    pose_array_msg.header.frame_id = \"map\";\n    for (const landmark_manager::Landmark & landmark : detected_landmarks) {\n      const Pose detected_marker_on_map =\n        autoware_utils_geometry::transform_pose(landmark.pose, self_pose);\n      pose_array_msg.poses.push_back(detected_marker_on_map);\n    }\n    pub_marker_detected_->publish(pose_array_msg);\n  }\n\n  // (4) calculate diff pose\n  const Pose new_self_pose =\n    landmark_manager_.calculate_new_self_pose(detected_landmarks, self_pose, false);\n\n  const double diff_x = new_self_pose.position.x - self_pose.position.x;\n  const double diff_y = new_self_pose.position.y - self_pose.position.y;\n\n  const double diff_norm = std::hypot(diff_x, diff_y);\n  const bool is_exist_marker_within_lanelet2_map =\n    diff_norm < param_.limit_distance_from_self_pose_to_marker;\n\n  diagnostics_interface_->add_key_value(\"distance_lanelet2_marker_to_detected_marker\", diff_norm);\n  if (!is_exist_marker_within_lanelet2_map) {\n    std::stringstream message;\n    message << \"The distance from lanelet2 to the detect marker is too far(\" << diff_norm\n            << \" [m]). The limit is \" << param_.limit_distance_from_self_pose_to_marker << \".\";\n    RCLCPP_INFO_STREAM_THROTTLE(this->get_logger(), *this->get_clock(), 1000, message.str());\n    diagnostics_interface_->update_level_and_message(\n      diagnostic_msgs::msg::DiagnosticStatus::WARN, message.str());\n    return;\n  }\n\n  // (5) Apply diff pose to self pose\n  // only x and y is changed\n  PoseWithCovarianceStamped result;\n  result.header.stamp = sensor_ros_time;\n  result.header.frame_id = \"map\";\n  result.pose.pose.position.x = new_self_pose.position.x;\n  result.pose.pose.position.y = new_self_pose.position.y;\n  result.pose.pose.position.z = self_pose.position.z;\n  result.pose.pose.orientation = self_pose.orientation;\n\n  // set covariance\n  const Eigen::Quaterniond map_to_base_link_quat = Eigen::Quaterniond(\n    result.pose.pose.orientation.w, result.pose.pose.orientation.x, result.pose.pose.orientation.y,\n    result.pose.pose.orientation.z);\n  const Eigen::Matrix3d map_to_base_link_rotation =\n    map_to_base_link_quat.normalized().toRotationMatrix();\n  result.pose.covariance = rotate_covariance(param_.base_covariance, map_to_base_link_rotation);\n\n  pub_base_link_pose_with_covariance_on_map_->publish(result);\n  pub_debug_pose_with_covariance_->publish(result);\n\n  // for debug\n  const landmark_manager::Landmark nearest_detected_landmark =\n    get_nearest_landmark(self_pose, detected_landmarks);\n  const auto marker_pointcloud_msg_ptr =\n    extract_marker_pointcloud(points_msg_ptr, nearest_detected_landmark.pose);\n  pub_marker_pointcloud_->publish(*marker_pointcloud_msg_ptr);\n\n  // save log\n  if (param_.enable_save_log) {\n    save_detected_marker_log(marker_pointcloud_msg_ptr);\n  }\n}"
    },
    {
        "line": 200,
        "character": 43,
        "functionName": "ekf_pose_buffer_->interpolate(sensor_ros_time)",
        "firstLine": "    interpolate_result = ekf_pose_buffer_->interpolate(sensor_ros_time);"
    },
    {
        "line": 215,
        "character": 75,
        "functionName": "interpolate_result.value().interpolated_pose.pose.pose",
        "firstLine": "  const Pose self_pose = interpolate_result.value().interpolated_pose.pose.pose;"
    }
]